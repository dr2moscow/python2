Index: Урок 1. Практическое задание/task_4.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 4.\r\n\r\nДля этой задачи:\r\n1) придумайте 2-3 решения (не менее двух)\r\n2) оцените сложность каждого решения в нотации О-большое\r\n3) сделайте вывод, какое решение эффективнее и почему\r\n\r\nПримечание:\r\nБез выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить\r\nчерез строки документации в самом коде.\r\nЕсли у вас возникают сложности, постарайтесь подумать как можно решить задачу,\r\nа не писать \"мы это не проходили)\".\r\nАлгоритмизатор должен развивать мышление, а это прежде всего практика.\r\nА без столкновения со сложностями его не развить.\r\n\r\nСама задача:\r\nПользователи веб-ресурса проходят аутентификацию.\r\nВ системе хранятся логин, пароль и отметка об активации учетной записи.\r\n\r\nНужно реализовать проверку, может ли пользователь быть допущен к ресурсу.\r\nПри этом его учетка должна быть активирована.\r\nА если нет, то польз-лю нужно предложить ее пройти.\r\n\r\nПриложение должно давать ответы на эти вопросы и быть реализовано в виде функции.\r\nДля реализации хранилища можно применить любой подход,\r\nкоторый вы придумаете, например, реализовать словарь.\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 1. Практическое задание/task_4.py b/Урок 1. Практическое задание/task_4.py
--- a/Урок 1. Практическое задание/task_4.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 1. Практическое задание/task_4.py	(date 1617822065338)
@@ -1,11 +1,9 @@
 """
 Задание 4.
-
 Для этой задачи:
 1) придумайте 2-3 решения (не менее двух)
 2) оцените сложность каждого решения в нотации О-большое
 3) сделайте вывод, какое решение эффективнее и почему
-
 Примечание:
 Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
 через строки документации в самом коде.
@@ -13,16 +11,48 @@
 а не писать "мы это не проходили)".
 Алгоритмизатор должен развивать мышление, а это прежде всего практика.
 А без столкновения со сложностями его не развить.
-
 Сама задача:
 Пользователи веб-ресурса проходят аутентификацию.
 В системе хранятся логин, пароль и отметка об активации учетной записи.
-
 Нужно реализовать проверку, может ли пользователь быть допущен к ресурсу.
 При этом его учетка должна быть активирована.
 А если нет, то польз-лю нужно предложить ее пройти.
-
 Приложение должно давать ответы на эти вопросы и быть реализовано в виде функции.
 Для реализации хранилища можно применить любой подход,
 который вы придумаете, например, реализовать словарь.
 """
+
+
+# Решение 1. Уровень сложности O(1)
+def verify_1(let, p):
+    if let in log_data.values():
+        if log_data['password'] == p:
+            if log_data['true'] == '1':
+                print('Добро пожаловать!')
+                return
+            print('Ваша учетная запись заблокирована!')
+            return
+        print('Некорректный пароль!')
+        return
+    print('Некорректный логин!')
+    return
+
+
+# Решение 2. Уровень сложности O(len(n))
+def verify_2(let, p):
+    dict_1 = {'login': let, 'password': p}
+    if dict_1['login'] == log_data['login'] and dict_1['password'] == log_data['password']:
+        if log_data['true'] == '1':
+            print('Добро пожаловать!')
+            return
+        print('Ваша учетная запись заблокирована!')
+        return
+    print('Некоректный логин или пароль!')
+
+
+log_data = {'login': 'xxx', 'password': 'abc', 'true': '1'}
+
+verify_1('abc', 'xxx')
+verify_2('xxx', 'abc')
+
+# Вывод: первое решение имеет меньшую сложность
Index: Урок 1. Практическое задание/task_3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 3.\r\n\r\nДля этой задачи:\r\n1) придумайте 2-3 решения (не менее двух)\r\n2) оцените сложность каждого решения в нотации О-большое\r\n3) сделайте вывод, какое решение эффективнее и почему\r\n\r\nПримечание:\r\nБез выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить\r\nчерез строки документации в самом коде.\r\nЕсли у вас возникают сложности, постарайтесь подумать как можно решить задачу,\r\nа не писать \"мы это не проходили)\".\r\nАлгоритмизатор должен развивать мышление, а это прежде всего практика.\r\nА без столкновения со сложностями его не развить.\r\n\r\nСама задача:\r\nИмеется хранилище с информацией о компаниях: название и годовая прибыль.\r\nДля реализации хранилища можно применить любой подход,\r\nкоторый вы придумаете, например, реализовать словарь.\r\nРеализуйте поиск трех компаний с наибольшей годовой прибылью.\r\nВыведите результат.\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 1. Практическое задание/task_3.py b/Урок 1. Практическое задание/task_3.py
--- a/Урок 1. Практическое задание/task_3.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 1. Практическое задание/task_3.py	(date 1617822008697)
@@ -1,11 +1,9 @@
 """
 Задание 3.
-
 Для этой задачи:
 1) придумайте 2-3 решения (не менее двух)
 2) оцените сложность каждого решения в нотации О-большое
 3) сделайте вывод, какое решение эффективнее и почему
-
 Примечание:
 Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
 через строки документации в самом коде.
@@ -13,7 +11,6 @@
 а не писать "мы это не проходили)".
 Алгоритмизатор должен развивать мышление, а это прежде всего практика.
 А без столкновения со сложностями его не развить.
-
 Сама задача:
 Имеется хранилище с информацией о компаниях: название и годовая прибыль.
 Для реализации хранилища можно применить любой подход,
@@ -21,3 +18,30 @@
 Реализуйте поиск трех компаний с наибольшей годовой прибылью.
 Выведите результат.
 """
+
+
+# Решение 1, уровень сложности O(n log n)
+def top_company(comp_list):
+    top = sorted(comp_list, key = comp_list.get, reverse = True)[:3]
+    return top
+
+
+# Решение 2, уровень сложности O(n^2)
+def top_company_2(company_list, q_data):
+    top = []
+    max_list = []
+    for i in company_list.values():
+        top.append(i)
+    for x in range(q_data):
+        max_profit = max(top)
+        max_list.append(max_profit)
+        top.remove(max_profit)
+    return max_list
+
+
+company = {'BMW': 200100, 'AUDI': 7500, 'Sberbank': 50000, 'VTB': 222, 'Google': 921200, 'HH': 10}
+
+print(top_company(company))
+print(top_company_2(company, 3))
+
+# Решение 1 визуально выглядит лучше и по уровню сложности лучше, т.к. сложность O(n log n) меньше, чем O(n^)
Index: Урок 1. Практическое задание/task_2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 2.\r\n\r\nРеализуйте два алгоритма.\r\n\r\nПервый, в виде функции, должен обеспечивать поиск минимального значения для списка.\r\nВ основе алгоритма должно быть сравнение каждого числа со всеми другими элементами списка.\r\nСложность такого алгоритма: O(n^2) - квадратичная.\r\n\r\nВторой, в виде функции, должен обеспечивать поиск минимального значения для списка.\r\nСложность такого алгоритма: O(n) - линейная.\r\n\r\nНе забудьте указать где какая сложность.\r\n\r\nПримечание:\r\nПостроить список можно через списковое включение.\r\nЕсли у вас возникают сложности, постарайтесь подумать как можно решить задачу,\r\nа не писать \"мы это не проходили)\".\r\nАлгоритмизатор должен развивать мышление, а это прежде всего практика.\r\nА без столкновения со сложностями его не развить.\r\n\"\"\"
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 1. Практическое задание/task_2.py b/Урок 1. Практическое задание/task_2.py
--- a/Урок 1. Практическое задание/task_2.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 1. Практическое задание/task_2.py	(date 1617821965469)
@@ -1,21 +1,41 @@
 """
 Задание 2.
-
 Реализуйте два алгоритма.
-
 Первый, в виде функции, должен обеспечивать поиск минимального значения для списка.
 В основе алгоритма должно быть сравнение каждого числа со всеми другими элементами списка.
 Сложность такого алгоритма: O(n^2) - квадратичная.
-
 Второй, в виде функции, должен обеспечивать поиск минимального значения для списка.
 Сложность такого алгоритма: O(n) - линейная.
-
 Не забудьте указать где какая сложность.
-
 Примечание:
 Построить список можно через списковое включение.
 Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
 а не писать "мы это не проходили)".
 Алгоритмизатор должен развивать мышление, а это прежде всего практика.
 А без столкновения со сложностями его не развить.
-"""
\ No newline at end of file
+"""
+
+
+# 1. Функция поиска минимального значания из списка, сложность O(n^2) - квадратичная
+def min_search(min_list):
+    min_o = min_list[0]
+    for el in min_list:
+        for el2 in min_list:
+            if el < el2 and el < min_o:
+                min_o = el
+    return min_o
+
+
+# 2. Функция поиска минимального значания из списка, сложность O(n) - линейная
+def min_search_2(min_list):
+    min_o = min_list[0]
+    for el in min_list:
+        if el < min_o:
+            min_o = el
+    return min_o
+
+
+lenta = [2, 7, 9, 12, 33, 5, 0, -2, -5]
+
+print(min_search(lenta))
+print(min_search_2(lenta))
Index: Урок 1. Практическое задание/task_1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 1.\r\n\r\nДля каждой из трех задач выполнить следующее:\r\n\r\n1) для каждой инструкции рядом в комментарии определите сложность этой инструкции\r\n2) определите сложность алгоритма в целом\r\n\r\nукажите сложность непосредственно в этом файле\r\nточки, где нужно поработать вам, отмечены знаком '!!!'\r\nНе забудтье оценить итоговую сложность каждого из трех алгоритмов.\r\n\r\nПримечание:\r\nЕсли у вас возникают сложности, постарайтесь подумать как можно решить задачу,\r\nа не писать \"мы это не проходили)\".\r\nАлгоритмизатор должен развивать мышление, а это прежде всего практика.\r\nА без столкновения со сложностями его не развить.\r\n\"\"\"\r\n\r\nimport random\r\n\r\n\r\n#############################################################################################\r\ndef check_1(lst_obj):\r\n    \"\"\"Функция должна создать множество из списка.\r\n\r\n    Алгоритм 3:\r\n    Создать множество из списка\r\n\r\n    Сложность: !!!.\r\n    \"\"\"\r\n    lst_to_set = set(lst_obj)  # !!!\r\n    return lst_to_set  # !!!\r\n\r\n\r\n#############################################################################################\r\ndef check_2(lst_obj):\r\n    \"\"\"Функция должная вернуть True, если все элементы списка различаются.\r\n\r\n    Алгоритм 1:\r\n    Проходимся по списку и для каждого элемента проверяем,\r\n    что такой элемент отстутствует\r\n    в оставшихся справа элементах\r\n\r\n    Сложность: !!!.\r\n    \"\"\"\r\n    for j in range(len(lst_obj)):          # !!!\r\n        if lst_obj[j] in lst_obj[j+1:]:    # !!!\r\n            return False                   # !!!\r\n    return True                            # !!!\r\n\r\n\r\n#############################################################################################\r\ndef check_3(lst_obj):\r\n    \"\"\"Функция должная вернуть True, если все элементы списка различаются.\r\n\r\n    Алгоритм 2:\r\n    Вначале выполним для списка сортировку, далее, сравниваем элементы попарно\r\n    Если присутствуют дубли, они будут находиться рядом.\r\n\r\n    Сложность: !!!\r\n    \"\"\"\r\n    lst_copy = list(lst_obj)                 # !!!\r\n    lst_copy.sort()                          # !!!\r\n    for i in range(len(lst_obj) - 1):        # !!!\r\n        if lst_copy[i] == lst_copy[i+1]:     # !!!\r\n            return False                     # !!!\r\n    return True                              # !!!\r\n\r\n#############################################################################################\r\n\r\n\r\nfor j in (50, 500, 1000, 5000, 1000):\r\n    # Из 100000 чисел возьмем 'j' случайно выбранных\r\n    # Всего 10 тыс. чисел\r\n    lst = random.sample(range(-100000, 100000), j)\r\n\r\nprint(check_1(lst))\r\nprint(check_2(lst))\r\nprint(check_3(lst))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 1. Практическое задание/task_1.py b/Урок 1. Практическое задание/task_1.py
--- a/Урок 1. Практическое задание/task_1.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 1. Практическое задание/task_1.py	(date 1617821884634)
@@ -1,15 +1,11 @@
 """
 Задание 1.
-
 Для каждой из трех задач выполнить следующее:
-
 1) для каждой инструкции рядом в комментарии определите сложность этой инструкции
 2) определите сложность алгоритма в целом
-
 укажите сложность непосредственно в этом файле
 точки, где нужно поработать вам, отмечены знаком '!!!'
 Не забудтье оценить итоговую сложность каждого из трех алгоритмов.
-
 Примечание:
 Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
 а не писать "мы это не проходили)".
@@ -23,49 +19,43 @@
 #############################################################################################
 def check_1(lst_obj):
     """Функция должна создать множество из списка.
-
     Алгоритм 3:
     Создать множество из списка
-
     Сложность: !!!.
     """
-    lst_to_set = set(lst_obj)  # !!!
-    return lst_to_set  # !!!
+    lst_to_set = set(lst_obj)  # !!! O(n)
+    return lst_to_set  # !!! O(1)
 
 
 #############################################################################################
 def check_2(lst_obj):
     """Функция должная вернуть True, если все элементы списка различаются.
-
     Алгоритм 1:
     Проходимся по списку и для каждого элемента проверяем,
     что такой элемент отстутствует
     в оставшихся справа элементах
-
     Сложность: !!!.
     """
-    for j in range(len(lst_obj)):          # !!!
-        if lst_obj[j] in lst_obj[j+1:]:    # !!!
-            return False                   # !!!
-    return True                            # !!!
+    for j in range(len(lst_obj)):          # !!! O(len(n)) - кол-во операций зависит от длины списка
+        if lst_obj[j] in lst_obj[j+1:]:    # !!! O(n)
+            return False                   # !!! O(1)
+    return True                            # !!! O(1)
 
 
 #############################################################################################
 def check_3(lst_obj):
     """Функция должная вернуть True, если все элементы списка различаются.
-
     Алгоритм 2:
     Вначале выполним для списка сортировку, далее, сравниваем элементы попарно
     Если присутствуют дубли, они будут находиться рядом.
-
     Сложность: !!!
     """
-    lst_copy = list(lst_obj)                 # !!!
-    lst_copy.sort()                          # !!!
-    for i in range(len(lst_obj) - 1):        # !!!
-        if lst_copy[i] == lst_copy[i+1]:     # !!!
-            return False                     # !!!
-    return True                              # !!!
+    lst_copy = list(lst_obj)                 # !!! O(n)
+    lst_copy.sort()                          # !!! O(n log n)
+    for i in range(len(lst_obj) - 1):        # !!! O(n)
+        if lst_copy[i] == lst_copy[i+1]:     # !!! O(1)
+            return False                     # !!! O(1)
+    return True                              # !!! O(1)
 
 #############################################################################################
 
Index: Урок 3. Практическое задание/task_4.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 4.\r\nРеализуйте скрипт \"Кэширование веб-страниц\"\r\n\r\nФункция должна принимать url-адрес и проверять\r\nесть ли в кэше соответствующая страница, если нет, то вносит ее в кэш\r\n\r\nПодсказка: задачу решите обязательно с применением 'соленого' хеширования и хеш-таблиц\r\nМожете условжнить задачу, реализовав ее через ООП\r\nНе забудьте, что кэширование - механизм, а хеш-таблица - средство его реализации\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 3. Практическое задание/task_4.py b/Урок 3. Практическое задание/task_4.py
--- a/Урок 3. Практическое задание/task_4.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 3. Практическое задание/task_4.py	(date 1617820537177)
@@ -9,3 +9,32 @@
 Можете условжнить задачу, реализовав ее через ООП
 Не забудьте, что кэширование - механизм, а хеш-таблица - средство его реализации
 """
+from hashlib import sha256
+
+
+def memorize(func):
+    def get(url, memory = {}):
+        read = memory.get(sha256(url.encode('utf-8')).hexdigest())
+        if read is None:
+            read = func(url)
+            print(f'url {url} был добавлен в кеш')
+            memory[sha256(url.encode('utf-8')).hexdigest()] = read
+            print(memory)
+        else:
+            print(f'url {url} ранее уже был добавлен в кеш')
+        return read
+    return get
+
+
+@memorize
+def check_url(url):
+    return url
+
+
+url_count = 1
+while url_count == 1:
+    url_input = input('Введите url (или нажмите Enter для выхода): ')
+    if url_input == "":
+        break
+    else:
+        check_url(url_input)
Index: Урок 3. Практическое задание/task_1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 1.\r\n\r\nРеализуйте свои пользовательские функции, в которых реализуйте:\r\n\r\na) заполнение списка и словаря программно,\r\n   сделайте замеры и сделайте выводы, что выполняется быстрее и почему\r\nb) выполните набор операций и со списком, и со словарем,\r\n   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему\r\n\r\nПодсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)\r\n\r\nПримечание: eсли вы уже знаете, что такое декоратор и как его реализовать,\r\nто реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций\r\nИ примените ее к своим функциям!\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 3. Практическое задание/task_1.py b/Урок 3. Практическое задание/task_1.py
--- a/Урок 3. Практическое задание/task_1.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 3. Практическое задание/task_1.py	(date 1617821813631)
@@ -14,3 +14,65 @@
 то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
 И примените ее к своим функциям!
 """
+from time import time
+
+size = 30 ** 5
+
+
+def timer(func):
+    def call_func(*args):
+        start_time = time()
+        result = func(*args)
+        print(f'Функция выполнялась: {round(time() - start_time, 4)} секунд')
+        return result
+
+    return call_func
+
+
+@timer
+def fill_lst(n):
+    return [i for i in range(n)]
+
+
+@timer
+def fill_dict(n):
+    return {i: i for i in range(n)}
+
+
+print('Вызов заполнения списка')
+fill_lst(size)
+print(f'\nВызов заполнения словаря')
+test_dict = fill_dict(size)
+
+
+# Словарь заполняется медлнее спика, причина - нужно время для генерации хэшей.
+# Для свяязки двух значений в списке добавляем в список кортежи. Заполнение происходит быстрей.
+@timer
+def fill_links_lst(n):
+    return [(i, i) for i in range(n)]
+
+
+print('------------------------------------------------------')
+print(f'\nВызов заполнения списка со связями двух значений')
+test_lst = fill_links_lst(size)
+
+
+# Ищем какое значение связно с другим в словаре
+@timer
+def check_search_lst(lst, el):
+    for i in range(len(lst)):
+        if lst[i][0] == el:
+            return lst[i][1]
+
+
+@timer
+def check_search_dict(d, el):
+    return d[el]
+
+
+print('------------------------------------------------------')
+print(f'\nВызов поиска в списке ')
+check_search_lst(test_lst, 841)
+print(f'\nВызов поиска в словаре')
+check_search_dict(test_dict, 841)
+
Index: Урок 1. Практическое задание/task_7.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 7.\r\nЗадание на закрепление навыков работы с деком\r\n\r\nВ рассмотренном на уроке листинге есть один недостаток\r\nПриведенный код способен \"обработать\" только строку без пробелов, например, 'топот'\r\n\r\nНо могут быть и такие палиндромы, как 'молоко делили ледоколом'\r\n\r\nВам нужно доработать программу так, чтобы она могла выполнить проверку на палиндром\r\nи в таких строках (включающих пробелы)\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 1. Практическое задание/task_7.py b/Урок 1. Практическое задание/task_7.py
--- a/Урок 1. Практическое задание/task_7.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 1. Практическое задание/task_7.py	(date 1617822193313)
@@ -1,12 +1,29 @@
 """
 Задание 7.
 Задание на закрепление навыков работы с деком
-
 В рассмотренном на уроке листинге есть один недостаток
 Приведенный код способен "обработать" только строку без пробелов, например, 'топот'
-
 Но могут быть и такие палиндромы, как 'молоко делили ледоколом'
-
 Вам нужно доработать программу так, чтобы она могла выполнить проверку на палиндром
 и в таких строках (включающих пробелы)
 """
+
+
+def reverse(words):
+    return words[::-1]
+
+
+def isPalindrome(words):
+    if words == reverse(words):
+        return True
+    return False
+
+
+word = 'молоко делили ледоколом'
+word = word.replace(' ', '')
+answer = isPalindrome(word)
+
+if answer == 1:
+    print("Это палиндром")
+else:
+    print("Это не палиндром")
Index: Урок 1. Практическое задание/task_6.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 6.\r\nЗадание на закрепление навыков работы с очередью\r\n\r\nПримечание: в этом задании вспомните ваши знания по работе с ООП\r\nи опирайтесь на пример урока\r\n\r\nРеализуйте структуру \"доска задач\".\r\n\r\nСтруктура должна предусматривать наличие несольких очередей задач, например\r\n1) базовой, откуда задачи берутся, решаются и отправляются в список решенных\r\n2) очередь на доработку, когда нерешенные задачи из первой очереди отправляются\r\nна корректировку решения\r\n\r\nПосле реализации структуры, проверьте ее работу на различных сценариях\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 1. Практическое задание/task_6.py b/Урок 1. Практическое задание/task_6.py
--- a/Урок 1. Практическое задание/task_6.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 1. Практическое задание/task_6.py	(date 1617822117915)
@@ -1,16 +1,79 @@
 """
 Задание 6.
 Задание на закрепление навыков работы с очередью
-
 Примечание: в этом задании вспомните ваши знания по работе с ООП
 и опирайтесь на пример урока
-
 Реализуйте структуру "доска задач".
-
 Структура должна предусматривать наличие несольких очередей задач, например
 1) базовой, откуда задачи берутся, решаются и отправляются в список решенных
 2) очередь на доработку, когда нерешенные задачи из первой очереди отправляются
 на корректировку решения
-
 После реализации структуры, проверьте ее работу на различных сценариях
 """
+
+
+class TaskBoard:
+    """Класс структуры"""
+    def __init__(self):
+        self.__solved = []  # Список решенных задач
+        self.__basic = Queue()  # Очередь решаемых задач
+        self.__revision = Queue()  # Очередь на доработку
+
+    def add_task(self, task):
+        """Добавляет задачу в список решаемых"""
+        self.__basic.add(task)
+
+    def move_to_revision(self):
+        """Перемещает последнюю задачу из решаемых на доработку"""
+        self.__revision.add(self.__basic.remove())
+
+    def move_to_solved(self):
+        """Перемещает последнюю задачу из решаемых в решенные"""
+        self.__solved.append(self.__basic.remove())
+
+    def complete_revision(self):
+        """Перемещает последнюю задачу из списка на дорабоке в решенные"""
+        self.__solved.append(self.__revision.remove())
+
+    def __str__(self):
+        return 'Решаемые задачи: ' + str(self.__basic) + '\nЗадачи на доработку: ' + str(self.__revision) + \
+               '\nЗавершенные задачи: ' + ', '.join(self.__solved) + '\n'
+
+
+class Queue:
+    """Класс очереди"""
+    def __init__(self):
+        self.__lst = []
+
+    def add(self, element):
+        """Добавляет элемент в очередь"""
+        self.__lst.insert(0, element)
+
+    def remove(self):
+        """Убирает элемент из очереди"""
+        return self.__lst.pop()
+
+    def __len__(self):
+        """Возвращает длину очереди"""
+        return len(self.__lst)
+
+    def __str__(self):
+        return ', '.join(reversed(self.__lst))
+
+
+task_board = TaskBoard()
+
+task_board.add_task('собрать команду')
+task_board.add_task('придумать план')
+print(task_board)
+
+task_board.move_to_revision()
+print(task_board)
+
+task_board.add_task('назначить встречу')
+task_board.move_to_solved()
+print(task_board)
+
+task_board.complete_revision()
+task_board.move_to_solved()
+print(task_board)
Index: Урок 1. Практическое задание/task_5.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 5.\r\nЗадание на закрепление навыков работы со стеком\r\n\r\nПримечание: в этом задании вспомните ваши знания по работе с ООП\r\nи опирайтесь на пример урока\r\n\r\nРеализуйте структуру \"стопка тарелок\".\r\n\r\nМы можем складывать тарелки в стопку и при превышении некоторого значения\r\nнужно начать складывать тарелки в новую стопку.\r\n\r\nСтруктура должна предусматривать наличие нескольких стеков.\r\nСоздание нового стека происходит при достижении предыдущим стеком порогового значения.\r\nРеализуйте по аналогии с примером, рассмотренным на уроке, необходимые методы,\r\nдля реализации это структуры, добавьте новые методы (не рассмотренные в примере с урока)\r\nдля реализации этой задачи.\r\n\r\nПосле реализации структуры, проверьте ее работу на различных сценариях\r\n\r\nПодсказка:\r\nОтдельне стопки можно реализовать через:\r\n# 1) созд-е экземпляров стека (если стопка - класс)\r\n# 2) lst = [[], [], [], [],....]\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 1. Практическое задание/task_5.py b/Урок 1. Практическое задание/task_5.py
--- a/Урок 1. Практическое задание/task_5.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 1. Практическое задание/task_5.py	(date 1617822089982)
@@ -1,25 +1,74 @@
 """
 Задание 5.
 Задание на закрепление навыков работы со стеком
-
 Примечание: в этом задании вспомните ваши знания по работе с ООП
 и опирайтесь на пример урока
-
 Реализуйте структуру "стопка тарелок".
-
 Мы можем складывать тарелки в стопку и при превышении некоторого значения
 нужно начать складывать тарелки в новую стопку.
-
 Структура должна предусматривать наличие нескольких стеков.
 Создание нового стека происходит при достижении предыдущим стеком порогового значения.
 Реализуйте по аналогии с примером, рассмотренным на уроке, необходимые методы,
 для реализации это структуры, добавьте новые методы (не рассмотренные в примере с урока)
 для реализации этой задачи.
-
 После реализации структуры, проверьте ее работу на различных сценариях
-
 Подсказка:
 Отдельне стопки можно реализовать через:
 # 1) созд-е экземпляров стека (если стопка - класс)
 # 2) lst = [[], [], [], [],....]
 """
+
+
+class PlateStack:
+    def __init__(self, limit):
+        self.limit = limit
+        self.__stacks = []
+
+    def add(self, number_of_plates = 1):
+        for i in range(number_of_plates):
+            if len(self.__stacks) == 0 or len(self.__stacks[-1]) == self.limit:
+                self.__stacks.append(Stack())
+            self.__stacks[-1].add('Тарелка')
+
+    def remove(self, number_of_plates = 1):
+        for i in range(number_of_plates):
+            if len(self.__stacks) == 0:
+                return
+            self.__stacks[-1].pop()
+            if len(self.__stacks[-1]) == 0:
+                self.__stacks.pop()
+
+    def __str__(self):
+        s = ' '.join([str(len(stack)) for stack in self.__stacks])
+        return 'Количество стопок: ' + str(len(self.__stacks)) + '\nСостояние стопок: ' + s + '\n'
+
+
+class Stack:
+    def __init__(self):
+        self.__lst = []
+
+    def add(self, element):
+        self.__lst.append(element)
+
+    def pop(self):
+        return self.__lst.pop()
+
+    def __len__(self):
+        return len(self.__lst)
+
+
+# Задаем количество тарелок в стопке
+print("В одной стопке 4 тарелки\n")
+plate_stack = PlateStack(4)
+
+print("Добавялем 5 тарелок в стопку")
+plate_stack.add(5)
+print(plate_stack)
+
+print("Добавялем 13 тарелки в стопки")
+plate_stack.add(13)
+print(plate_stack)
+
+print("Удаляем 11 тарелок из стопки")
+plate_stack.remove(7)
+print(plate_stack)
Index: Урок 2. Практическое задание/task_7.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\n7.\tНапишите программу, доказывающую или проверяющую, что для множества\r\nнатуральных чисел выполняется равенство: 1+2+...+n = n(n+1)/2,\r\nгде n - любое натуральное число.\r\nРекурсия вам нужна для решения левой части выражения.\r\nПолученный результат нужно просто сравнить с результатом в правой.\r\n\r\nПример:\r\nдля n = 5\r\n1+2+3+4+5 = 5(5+1)/2\r\n\r\nПодсказка:\r\nВ ф-цию принимаются два элемент - это левая и правая части\r\n\r\nРешите через рекурсию. Решение через цикл не принимается.\r\nДля оценки Отлично в этом блоке необходимо выполнить 5 заданий из 7\r\n\"\"\"\r\n\r\n\r\ndef func(n, i = 0, left = 0):\r\n\tif n == 0:\r\n\t\treturn 'Равенство выполнется'\r\n\tleft += i + 1\r\n\tif left != (i + 1) * (i + 2) // 2:\r\n\t\treturn 'Равенство не выполнется'\r\n\treturn func(n - 1, i + 1, left)\r\n\r\n\r\nnumber = int(input('Введите число: '))\r\nprint(func(number))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 2. Практическое задание/task_7.py b/Урок 2. Практическое задание/task_7.py
--- a/Урок 2. Практическое задание/task_7.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 2. Практическое задание/task_7.py	(date 1617817483964)
@@ -18,12 +18,12 @@
 
 
 def func(n, i = 0, left = 0):
-	if n == 0:
-		return 'Равенство выполнется'
-	left += i + 1
-	if left != (i + 1) * (i + 2) // 2:
-		return 'Равенство не выполнется'
-	return func(n - 1, i + 1, left)
+    if n == 0:
+        return 'Равенство выполнется'
+    left += i + 1
+    if left != (i + 1) * (i + 2) // 2:
+        return 'Равенство не выполнется'
+    return func(n - 1, i + 1, left)
 
 
 number = int(input('Введите число: '))
Index: Урок 2. Практическое задание/task_5.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\n5.\tВывести на экран коды и символы таблицы ASCII, начиная с символа\r\nпод номером 32 и заканчивая 127-м включительно.\r\nВывод выполнить в табличной форме: по десять пар \"код-символ\" в каждой строке.\r\n\r\nПример:\r\n32 -   33 - ! 34 - \" 35 - # 36 - $ 37 - % 38 - & 39 - ' 40 - ( 41 - )\r\n42 - * 43 - + 44 - , 45 - - 46 - . 47 - / 48 - 0 49 - 1 50 - 2 51 - 3\r\n52 - 4 53 - 5 54 - 6 55 - 7 56 - 8 57 - 9 58 - : 59 - ; 60 - < 61 - =\r\n62 - > 63 - ? 64 - @ 65 - A 66 - B 67 - C 68 - D 69 - E 70 - F 71 - G\r\n72 - H 73 - I 74 - J 75 - K 76 - L 77 - M 78 - N 79 - O 80 - P 81 - Q\r\n82 - R 83 - S 84 - T 85 - U 86 - V 87 - W 88 - X 89 - Y 90 - Z 91 - [\r\n92 - \\ 93 - ] 94 - ^ 95 - _ 96 - ` 97 - a 98 - b 99 - c 100 - d 101 - e\r\n102 - f 103 - g 104 - h 105 - i 106 - j 107 - k 108 - l 109 - m 110 - n 111 - o\r\n112 - p 113 - q 114 - r 115 - s 116 - t 117 - u 118 - v 119 - w 120 - x 121 - y\r\n122 - z 123 - { 124 - | 125 - } 126 - ~ 127 - \u007F\r\n\r\nРешите через рекурсию. Решение через цикл не принимается.\r\nДля оценки Отлично в этом блоке необходимо выполнить 5 заданий из 7\r\n\r\nПодсказка:\r\nДопускается исп-е встроенных ф-ций\r\nи допускается комб-е - цикл и рекурсия\r\n\"\"\"\r\n\r\n\r\ndef recursion(d1, d2, string='', count=1):\r\n    if d1 == d2:\r\n        string = string + f'{d2} - {chr(d2)}'\r\n        print(string)\r\n    else:\r\n        if count % 10 == 0:\r\n            string = string + f'{d1} - {chr(d1)} \\n'\r\n            recursion(d1 + 1, d2, string, count + 1)\r\n        else:\r\n            string = string + f'{d1} - {chr(d1)}'\r\n            recursion(d1 + 1, d2, string, count + 1)\r\n\r\n\r\nrecursion(32, 127)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 2. Практическое задание/task_5.py b/Урок 2. Практическое задание/task_5.py
--- a/Урок 2. Практическое задание/task_5.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 2. Практическое задание/task_5.py	(date 1617817483949)
@@ -24,7 +24,7 @@
 """
 
 
-def recursion(d1, d2, string='', count=1):
+def recursion(d1, d2, string = '', count = 1):
     if d1 == d2:
         string = string + f'{d2} - {chr(d2)}'
         print(string)
Index: Урок 2. Практическое задание/task_4.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\n4.\tНайти сумму n элементов следующего ряда чисел: 1 -0.5 0.25 -0.125 ...\r\nКоличество элементов (n) вводится с клавиатуры.\r\n\r\nПример:\r\nВведите количество элементов: 3\r\nКоличество элементов: 3, их сумма: 0.75\r\n\r\nРешите через рекурсию. Решение через цикл не принимается.\r\nДля оценки Отлично в этом блоке необходимо выполнить 5 заданий из 7\r\n\r\nПодсказка:\r\nКаждый очередной элемент в 2 раза меньше предыдущего и имеет противоположный знак\r\n\"\"\"\r\nobj = [1]\r\n\r\n\r\ndef recurcion(n):\r\n\tif n == 1:\r\n\t\tprint(f'Сумма элементов равна {sum(obj)}')\r\n\telse:\r\n\t\tif n % 2 == 0:\r\n\t\t\tobj.append(obj[-1] / -2)\r\n\t\t\trecurcion(n - 1)\r\n\t\telse:\r\n\t\t\tobj.append(obj[-1] / -2)\r\n\t\t\trecurcion(n - 1)\r\n\r\n\r\nnumber = int(input('Введите число: '))\r\nrecurcion(number)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 2. Практическое задание/task_4.py b/Урок 2. Практическое задание/task_4.py
--- a/Урок 2. Практическое задание/task_4.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 2. Практическое задание/task_4.py	(date 1617817360191)
@@ -16,15 +16,15 @@
 
 
 def recurcion(n):
-	if n == 1:
-		print(f'Сумма элементов равна {sum(obj)}')
-	else:
-		if n % 2 == 0:
-			obj.append(obj[-1] / -2)
-			recurcion(n - 1)
-		else:
-			obj.append(obj[-1] / -2)
-			recurcion(n - 1)
+    if n == 1:
+        print(f'Сумма элементов равна {sum(obj)}')
+    else:
+        if n % 2 == 0:
+            obj.append(obj[-1] / -2)
+            recurcion(n - 1)
+        else:
+            obj.append(obj[-1] / -2)
+            recurcion(n - 1)
 
 
 number = int(input('Введите число: '))
Index: Урок 2. Практическое задание/task_3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\n3.\tСформировать из введенного числа обратное по порядку входящих в него\r\nцифр и вывести на экран. Например, если введено число 3486,\r\n то надо вывести число 6843.\r\n\r\nПодсказка:\r\nНа каждом шаге вам нужно 'доставать' из числа очередную цифру\r\nПока все числа не извлечены рекурсивные вызовы продолжаем\r\nУсловие завершения рекурсии - все цифры извлечены\r\n\r\nИспользуем операции % //, НЕ ИСПОЛЬЗУЕМ ОПЕРАЦИИ ВЗЯТИЯ ЭЛЕМЕНТА ПО ИНДЕКСУ\r\n\r\nРешите через рекурсию. Решение через цикл не принимается.\r\nДля оценки Отлично в этом блоке необходимо выполнить 5 заданий из 7\r\n\r\nПример:\r\nВведите число, которое требуется перевернуть: 123\r\nПеревернутое число: 321\r\n\r\nНе забудьте проверить и на числах, заканчивающихся нулем.\r\nПример:\r\nВведите число, которое требуется перевернуть: 1230\r\nПеревернутое число: 0321\r\n\"\"\"\r\n\r\n\r\ndef roll(n):\r\n\tif len(n) == 1:\r\n\t\treturn n\r\n\treturn roll(n[1:]) + n[0]\r\n\r\n\r\nnumber = input('Введите число: ')\r\nprint(f'В обратном порядке: {roll(number)}')\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 2. Практическое задание/task_3.py b/Урок 2. Практическое задание/task_3.py
--- a/Урок 2. Практическое задание/task_3.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 2. Практическое задание/task_3.py	(date 1617817360206)
@@ -25,9 +25,9 @@
 
 
 def roll(n):
-	if len(n) == 1:
-		return n
-	return roll(n[1:]) + n[0]
+    if len(n) == 1:
+        return n
+    return roll(n[1:]) + n[0]
 
 
 number = input('Введите число: ')
Index: Урок 2. Практическое задание/task_2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\n2.\tПосчитать четные и нечетные цифры введенного натурального числа.\r\nНапример, если введено число 34560, то у него 3 четные цифры\r\n(4, 6 и 0) и 2 нечетные (3 и 5).\r\n\r\nПодсказка:\r\nНа каждом шаге вам нужно 'доставать' из числа очередную цифру\r\nи смотреть является ли она четной или нечетной. При этом увеличиваем соответствующий счетчик\r\nПока все числа не извлечены рекурсивные вызовы продолжаем\r\nУсловие завершения рекурсии - все числа извлечены\r\n\r\nИспользуем операции % //, НЕ ИСПОЛЬЗУЕМ ОПЕРАЦИИ ВЗЯТИЯ ЭЛЕМЕНТА ПО ИНДЕКСУ\r\n\r\nРешите через рекурсию. Решение через цикл не принимается.\r\nДля оценки Отлично в этом блоке необходимо выполнить 5 заданий из 7\r\n\r\nПример:\r\nВведите число: 123\r\nКоличество четных и нечетных цифр в числе равно: (1, 2)\r\n\"\"\"\r\n\r\n\r\ndef func(n):\r\n\tif n // 10 == 0:\r\n\t\treturn n % 2\r\n\treturn n % 2 + func(n // 10)\r\n\r\n\r\nnumber = int(input('Введите число: '))\r\nprint(f'Количество четных цифр {len(str(number)) - func(number)}, нечетных цифр {func(number)} в числе {number}')\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 2. Практическое задание/task_2.py b/Урок 2. Практическое задание/task_2.py
--- a/Урок 2. Практическое задание/task_2.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 2. Практическое задание/task_2.py	(date 1617817360197)
@@ -21,9 +21,9 @@
 
 
 def func(n):
-	if n // 10 == 0:
-		return n % 2
-	return n % 2 + func(n // 10)
+    if n // 10 == 0:
+        return n % 2
+    return n % 2 + func(n // 10)
 
 
 number = int(input('Введите число: '))
Index: Урок 2. Практическое задание/task_1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\n1.\tНаписать программу, которая будет складывать, вычитать, умножать или делить\r\nдва числа. Числа и знак операции вводятся пользователем. После выполнения\r\nвычисления программа не должна завершаться, а должна запрашивать новые данные\r\nдля вычислений. Завершение программы должно выполняться при вводе символа '0'\r\nв качестве знака операции. Если пользователь вводит неверный знак\r\n(не '0', '+', '-', '*', '/'), то программа должна сообщать ему об ошибке и\r\nснова запрашивать знак операции.\r\n\r\nТакже сообщать пользователю о невозможности деления на ноль,\r\nесли он ввел 0 в качестве делителя.\r\n\r\nПодсказка:\r\nВариант исполнения:\r\n- условие рекурсивного вызова - введена операция +, -, *, / - ШАГ РЕКУРСИИ\r\n- условие завершения рекурсии - введена операция 0 - БАЗОВЫЙ СЛУЧАЙ\r\n\r\nРешите через рекурсию. Решение через цикл не принимается.\r\nДля оценки Отлично в этом блоке необходимо выполнить 5 заданий из 7\r\n\r\nПример:\r\nВведите операцию (+, -, *, / или 0 для выхода): +\r\nВведите первое число: 214\r\nВведите второе число: 234\r\nВаш результат 448\r\nВведите операцию (+, -, *, / или 0 для выхода): -\r\nВведите первое число: вп\r\nВы вместо трехзначного числа ввели строку (((. Исправьтесь\r\nВведите операцию (+, -, *, / или 0 для выхода):\r\n\"\"\"\r\n\r\n\r\ndef calc():\r\n\toperation = input('Введите операцию (или 0 для выхода): ')\r\n\tif operation == '0':\r\n\t\treturn\r\n\tif operation not in ('+', '-', '*', '/'):\r\n\t\tprint('Я не знаю такой операцию! Попробуйте \"+\", \"-\", \"*\", \"/\"')\r\n\t\treturn calc()\r\n\ttry:\r\n\t\ta = float(input('Введите первое число: '))\r\n\t\tb = float(input('Введите второе число: '))\r\n\t\tprint('Результат:', a + b if operation == '+' else a - b if operation == '-' else a * b if operation == '*' else a / b)\r\n\texcept ValueError:\r\n\t\tprint('Вы ввели строку, которую невозможно преоброзовать в число')\r\n\treturn calc()\r\n\r\n\r\ncalc()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 2. Практическое задание/task_1.py b/Урок 2. Практическое задание/task_1.py
--- a/Урок 2. Практическое задание/task_1.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 2. Практическое задание/task_1.py	(date 1617817270454)
@@ -31,19 +31,19 @@
 
 
 def calc():
-	operation = input('Введите операцию (или 0 для выхода): ')
-	if operation == '0':
-		return
-	if operation not in ('+', '-', '*', '/'):
-		print('Я не знаю такой операцию! Попробуйте "+", "-", "*", "/"')
-		return calc()
-	try:
-		a = float(input('Введите первое число: '))
-		b = float(input('Введите второе число: '))
-		print('Результат:', a + b if operation == '+' else a - b if operation == '-' else a * b if operation == '*' else a / b)
-	except ValueError:
-		print('Вы ввели строку, которую невозможно преоброзовать в число')
-	return calc()
+    operation = input('Введите операцию (или 0 для выхода): ')
+    if operation == '0':
+        return
+    if operation not in ('+', '-', '*', '/'):
+        print('Я не знаю такой операцию! Попробуйте "+", "-", "*", "/"')
+        return calc()
+    try:
+        a = float(input('Введите первое число: '))
+        b = float(input('Введите второе число: '))
+        print('Результат:', a + b if operation == '+' else a - b if operation == '-' else a * b if operation == '*' else a / b)
+    except ValueError:
+        print('Вы ввели строку, которую невозможно преоброзовать в число')
+    return calc()
 
 
 calc()
Index: Урок 3. Практическое задание/task_3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 3.\r\nОпределить количество различных (уникальных) подстрок с использованием хеш-функции.\r\nДана строка S длиной N, состоящая только из строчных латинских букв.\r\n\r\nПодсказка: примените вычисление хешей для подстрок с помощью хеш-функций и множества\r\n\r\nПример:\r\nрара - 6 уникальных подстрок\r\n\r\nрар\r\nра\r\nар\r\nара\r\nр\r\nа\r\n\"\"\"\r\n\r\n# hash?\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 3. Практическое задание/task_3.py b/Урок 3. Практическое задание/task_3.py
--- a/Урок 3. Практическое задание/task_3.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 3. Практическое задание/task_3.py	(date 1617817926012)
@@ -15,5 +15,19 @@
 р
 а
 """
-
 # hash?
+
+
+def func(str_obj):
+    substrings = []
+    for i in range(len(str_obj) - 1):
+        substrings.append(str_obj[0:i + 1])
+        substrings.append(str_obj[i + 1:])
+    print(substrings)
+    substrings = set(substrings)
+    print(f'Колличество подстрок {len(substrings)}')
+    for i in substrings:
+        print(hash(i))
+
+
+func('архитектор')
Index: Урок 3. Практическое задание/task_2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nЗадание 2.\r\nВаша программа должна запрашивать пароль\r\nДля этого пароля вам нужно получить хеш, используя функцию sha256\r\nДля генерации хеша обязательно нужно использовать криптографическую соль\r\nОбязательно выведите созданный хеш\r\n\r\nДалее программа должна запросить пароль повторно\r\nВам нужно проверить, совпадает ли пароль с исходным\r\nДля проверки необходимо сравнить хеши паролей\r\n\r\nПРИМЕР:\r\nВведите пароль: 123\r\nВ базе данных хранится строка: 555a3581d37993843efd4eba1921f1dcaeeafeb855965535d77c55782349444b\r\nВведите пароль еще раз для проверки: 123\r\nВы ввели правильный пароль\r\n\r\nДопускаются любые усложения задания - валидация, подключение к БД, передача данных в файл\r\n\"\"\"\r\n# sqlite, postgres, db_api, orm\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Урок 3. Практическое задание/task_2.py b/Урок 3. Практическое задание/task_2.py
--- a/Урок 3. Практическое задание/task_2.py	(revision 0d9050aa8d2df9e4b5cc56498aefcda9e87790e3)
+++ b/Урок 3. Практическое задание/task_2.py	(date 1617817784073)
@@ -18,3 +18,29 @@
 Допускаются любые усложения задания - валидация, подключение к БД, передача данных в файл
 """
 # sqlite, postgres, db_api, orm
+from hashlib import sha256
+
+salt = 'teacher_is_first_profession'
+
+
+def create_hash(pwd):
+    global salt
+    return sha256(pwd.encode('utf-8') + salt.encode('utf-8')).hexdigest()
+
+
+def authorization(pwd):
+    global salt
+    with open('data.txt', 'r') as read_file:
+        return True if sha256(pwd.encode('utf-8') + salt.encode('utf-8')).hexdigest() == read_file.read() else False
+
+
+password_hash = create_hash(input('Введите пароль: '))
+print('Строка из файла:', password_hash)
+
+with open('data.txt', 'w') as write_file:
+    write_file.write(password_hash)
+
+del password_hash
+
+password = input('Введите пароль для проверки: ')
+print(f'Вы ввели {"" if authorization(password) else "не"}правильный пароль')
