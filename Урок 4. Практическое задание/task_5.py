"""
Задание 5.**
Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).
Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)
Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма
Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснвование рез-ам
"""
import timeit
from math import ceil


def simple(i):
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def sieve(n):
    a = list(range(n+1))
    lst = []
    i = 2
    m = n
    while len(lst) != n:
        if i == m:
            a += list(range(m+1, m*2+1))
            m *= 2
            for j in lst:
                for k in range(j * ceil(i / j), m, j):
                    a[k] = 0
        if a[i] != 0:
            lst.append(a[i])
            for j in range(i, n + 1, i):
                a[j] = 0
        i += 1
    return lst[-1]


number = 1000
print('Простой перебор:', timeit.timeit('simple(number)', setup='from __main__ import simple, number', number=10))
print('Решето Эратосфена:', timeit.timeit('sieve(number)', setup='from __main__ import sieve, number', number=10))

"""
Простой перебор: 4.870868499999999
Алгоритм Решето Эратосфена: 0.027606999999999715
"""

# Классичиский алгоритм решето Эратосфена, предполагает, что мы ищем простые числа до какого-либо числа n,
# а нужно найти n-ое простое число.
# Сначала найдем все простые до n, а затем если мы еще не нашли n простых чисел - расширяем решето в два раза,
# при этом исключая все числа, которые делятся на простые.
# Если поставить маленькие числа, то решето работает примерно с такой же скоростью, что и функция без него, но,
# когда стоит задача найти 10000-ое простое число, можно не дождаться, когда функция без решета вернет значение.
